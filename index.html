<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Randomiser tournament tracker</title>
<style>
:root{--bg:#f6fbff;--card-bg:#fff;--accent:#2d6cdf}
body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:#202124;margin:0;padding:24px}
.container{max-width:1100px;margin:0 auto}
h1{margin:0 0 8px;font-size:18px}
.stage{background:var(--card-bg);padding:14px;border-radius:8px;box-shadow:0 2px 6px rgba(0,0,0,.06);margin-bottom:18px}
label{display:block;margin:8px 0 6px;font-weight:600}
input[type=text], textarea{width:100%;box-sizing:border-box;padding:8px;border:1px solid #d1d7e0;border-radius:6px;font-size:13px}
textarea{height:140px;font-family:monospace;white-space:pre-wrap}
.row{display:flex;gap:12px}
.leftcol{width:150px}
.center{flex:1}
.btn{display:inline-block;padding:8px 12px;border-radius:6px;border:0;background:var(--accent);color:#fff;cursor:pointer}
.grid-wrap{display:flex;align-items:center;gap:12px}
.score-box{width:150px;background:#fff;padding:8px;border-radius:8px;border:1px solid #e6eefc;text-align:center}
.score-box h3{margin:6px 0;font-size:16px}
.grid-root{position:relative;display:flex;justify-content:center}
.grid{position:relative;display:grid;background:#f8fbff;border:1px solid #cbd9ff;padding:6px;border-radius:6px}
.cell{box-sizing:border-box;border:1px solid rgba(0,0,0,.06);padding:10px;display:flex;flex-direction:column;justify-content:center;align-items:center;font-size:13px;position:relative;overflow:hidden;text-align:center}
.item{font-weight:700;white-space:normal;overflow-wrap:break-word;word-break:normal}
.rarity{font-size:12px;opacity:.9;margin-top:6px}
.points{font-size:12px;opacity:.95;margin-top:6px}
.overlayMark{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:44px;pointer-events:none;opacity:0.55}
.overlayMark.x{color:rgba(222,36,36,0.78)}
.overlayMark.o{color:rgba(42,142,42,0.78)}
.line-layer{position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;z-index:2}
.lineOverlay{position:absolute;pointer-events:none;border-radius:6px}
.glow{animation:glow 1s ease-in-out infinite alternate}
@keyframes glow{from{box-shadow:0 0 10px rgba(255,215,0,0.6)}to{box-shadow:0 0 18px rgba(255,215,0,0.95)}}
.very-common{background:linear-gradient(#fff7d9,#ffe89c)}
.common{background:linear-gradient(#ffffff,#f5f5f7)}
.uncommon{background:linear-gradient(#e6ffdc,#b7f08a)}
.rare{background:linear-gradient(#d9f0ff,#7ecaff)}
.super-rare{background:linear-gradient(#f0dbff,#b98aff)}
.legend{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap}
.legend .key{padding:8px;border-radius:6px;font-weight:700;display:flex;gap:8px;align-items:center}
.muted{color:#666;font-size:13px}
.meta{margin-top:12px;color:#444}
@media (max-width:900px){.row{flex-direction:column}.leftcol{width:auto}.grid-wrap{flex-direction:column}}
</style>
</head>
<body>
<div class="container">
  <h1>Randomiser tournament tracker</h1>

  <div class="stage" id="step1">
    <div class="small muted">Step 1 — Enter team names</div>
    <label>Team X name</label>
    <input id="teamXName" type="text" placeholder="Team X" value="Team X" />
    <label>Team O name</label>
    <input id="teamOName" type="text" placeholder="Team O" value="Team O" />
    <div style="margin-top:12px;text-align:right">
      <button class="btn" id="toStep2">Next</button>
    </div>
  </div>

  <div class="stage" id="step2" style="display:none">
    <div class="small muted">Step 2 — Paste card text here. Supports ITEM [tab] RARITY, RARITY [tab] ITEM, or ITEM then next-line RARITY. Underscores → spaces automatically.</div>
    <label>Paste card</label>
    <textarea id="cardInput" placeholder="PASTE CARD TEXT (ITEM then RARITY etc)"></textarea>
    <div style="margin-top:8px;text-align:right">
      <button class="btn" id="parseBtn">Done</button>
    </div>
  </div>

  <div class="stage" id="viewer" style="display:none">
    <div class="row" style="align-items:center;margin-bottom:8px">
      <div class="leftcol score-box" id="scoreLeft">
        <h3 id="teamXDisplay">Team X</h3>
        <div style="font-size:36px;font-weight:800;color:#c33" id="scoreX">0</div>
      </div>

      <div class="center">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <div class="muted">Click a cell to cycle: X → O → none</div>
          <div>
            <button class="btn" id="resetMarks">Reset marks</button>
            <button class="btn" id="exportBtn" style="margin-left:6px;background:#27ae60">Export card text</button>
          </div>
        </div>

        <div class="grid-wrap">
          <div id="gridContainer" class="grid-root" style="flex:1;min-width:200px"></div>
        </div>

      </div>

      <div class="leftcol score-box" id="scoreRight">
        <h3 id="teamODisplay">Team O</h3>
        <div style="font-size:36px;font-weight:800;color:#2a8f2a" id="scoreO">0</div>
      </div>
    </div>

    <div class="legend" id="legend"></div>
    <div class="meta">Card size: <span id="cardSize"></span> — Points: Very Common=1, Common=2, Uncommon=4, Rare=8, Super Rare=16. Lines double points for the team that completes them (each cell doubled at most once).</div>
  </div>
</div>

<script>
// rarities and priority
const RARITIES = {
  'very common': {key:'Very Common', pts:1, cls:'very-common'},
  'common': {key:'Common', pts:2, cls:'common'},
  'uncommon': {key:'Uncommon', pts:4, cls:'uncommon'},
  'rare': {key:'Rare', pts:8, cls:'rare'},
  'super rare': {key:'Super Rare', pts:16, cls:'super-rare'}
};
const RARITY_RANK = {'super rare':5,'very common':4,'rare':3,'uncommon':2,'common':1};

let grid = [], N = 0, lines = {X:[],O:[]}, prevLines = {X:[],O:[]};

function normalizeRarity(s){
  if(!s) return null;
  s = String(s).trim().toLowerCase().replace(/_/g,' ').replace(/\s+/g,' ').trim();
  if(s === 'very common') return 'very common';
  if(s === 'super rare') return 'super rare';
  if(s === 'uncommon') return 'uncommon';
  if(s === 'rare') return 'rare';
  if(s === 'common') return 'common';
  if(s.includes('very') && s.includes('common')) return 'very common';
  if(s.includes('super') && s.includes('rare')) return 'super rare';
  if(s.includes('uncommon')) return 'uncommon';
  if(s.includes('rare')) return 'rare';
  if(s.includes('common')) return 'common';
  return null;
}
function formatItemName(n){ return n ? String(n).replace(/_/g,' ').replace(/\s+/g,' ').trim() : ''; }

/* NEW robust token-stream parser
   - Builds a flat ordered token list from input (split on newlines, tabs, or 2+ spaces)
   - Marks tokens that look like rarities
   - Walks tokens pairing item+rarity deterministically:
       * if token is rarity and next token is item -> pair(next,item)
       * else if token is item and next token is rarity -> pair(item,next)
       * else if token is item and next token absent or also item -> pair(item, '')
       * isolated rarity attaches to previous item if previous has no rarity
*/
function parseCardText(text){
  // split into tokens preserving order. use newlines and tabs and two+ spaces as separators
  // keep each token as original trimmed string
  const rawLines = text.split(/\r?\n/);
  const tokens = [];
  for(const ln of rawLines){
    if(!ln || !ln.trim()) continue;
    // split line by tabs or 2+ spaces
    const parts = ln.split(/\t| {2,}/).map(p=>p.trim()).filter(Boolean);
    // if the line didn't split (single part), still push that single token
    if(parts.length === 0) continue;
    for(const p of parts) tokens.push(p);
  }

  // convert tokens to objects {text, isRarity, normRarity}
  const tlist = tokens.map(t => {
    const norm = normalizeRarity(t);
    return { text: t, isRarity: !!norm, normR: norm };
  });

  // pair tokens
  const pairs = [];
  for(let i=0;i<tlist.length;){
    const cur = tlist[i];
    const next = tlist[i+1];
    // case: rarity then item
    if(cur.isRarity && next && !next.isRarity){
      pairs.push({ item: next.text, rarityRaw: cur.text, rarity: cur.normR });
      i += 2;
      continue;
    }
    // case: item then rarity
    if(!cur.isRarity && next && next.isRarity){
      pairs.push({ item: cur.text, rarityRaw: next.text, rarity: next.normR });
      i += 2;
      continue;
    }
    // case: both are rarities (weird) -> attach next token as item if present, else skip
    if(cur.isRarity && next && next.isRarity){
      // prefer stronger rarity for the rarity value and treat other as orphaned item if possible
      const rankA = RARITY_RANK[cur.normR]||0;
      const rankB = RARITY_RANK[next.normR]||0;
      const chosen = (rankA >= rankB) ? cur : next;
      // attach the other token as item if a following non-rarity exists
      if(tlist[i+2] && !tlist[i+2].isRarity){
        pairs.push({ item: tlist[i+2].text, rarityRaw: chosen.text, rarity: chosen.normR });
        i += 3; continue;
      } else {
        // fallback: skip one and treat current as rarity for an empty item
        pairs.push({ item: '', rarityRaw: chosen.text, rarity: chosen.normR });
        i += 1; continue;
      }
    }
    // case: item then item (no rarity between)
    if(!cur.isRarity && next && !next.isRarity){
      // treat current as item with empty rarity
      pairs.push({ item: cur.text, rarityRaw: '', rarity: null });
      i += 1;
      continue;
    }
    // last token single
    if(!next){
      if(cur.isRarity){
        // isolated rarity: attach to previous item if previous exists and had no rarity
        if(pairs.length > 0 && (!pairs[pairs.length-1].rarity || pairs[pairs.length-1].rarity === null)){
          pairs[pairs.length-1].rarityRaw = cur.text;
          pairs[pairs.length-1].rarity = cur.normR;
        } else {
          // no previous item: create empty item with this rarity
          pairs.push({ item: '', rarityRaw: cur.text, rarity: cur.normR });
        }
      } else {
        pairs.push({ item: cur.text, rarityRaw: '', rarity: null });
      }
      i += 1;
    }
  }

  // final mapping: normalize item names & ensure rarity fallback to null (we'll resolve later)
  return pairs.map(p => ({ item: formatItemName(p.item), rarityRaw: p.rarityRaw || '', rarity: p.rarity || null }));
}

/* BUILD GRID — authoritative resolution of rarity (defensive)
   Priority:
     1) parser-provided normalized rarity
     2) normalize(p.rarityRaw)
     3) look in combined raw for 'very common' or 'super rare' mentions
     4) fallback to 'common'
*/
function buildGridFromPairs(pairs){
  const count = pairs.length;
  const size = Math.sqrt(count);
  if(!Number.isInteger(size) || size < 1 || size > 10) return null;
  N = size; grid = [];
  for(let r=0;r<N;r++){
    const row = [];
    for(let c=0;c<N;c++){
      const p = pairs[r*N + c] || {};
      let item = formatItemName(p.item || '');
      let key = null;
      if(p.rarity) key = normalizeRarity(p.rarity);
      if(!key && p.rarityRaw) key = normalizeRarity(p.rarityRaw);
      const rawCombined = ((p.rarityRaw || '') + ' ' + (p.item || '')).toString().toLowerCase();
      if(!key){
        if(/very[_\-\s]*common/.test(rawCombined) || (rawCombined.includes('very') && rawCombined.includes('common'))) key = 'very common';
        else if(/super[_\-\s]*rare/.test(rawCombined) || (rawCombined.includes('super') && rawCombined.includes('rare'))) key = 'super rare';
      }
      if(!key) key = 'common';
      if(!RARITIES[key]) key = 'common';
      const meta = RARITIES[key];
      row.push({ item: item, rarityKey: key, basePts: meta.pts, mark: null });
    }
    grid.push(row);
  }
  return grid;
}

/* Render + gameplay (same behaviour as before) */
function renderGrid(){
  const container = document.getElementById('gridContainer'); container.innerHTML = '';
  const maxTotal = 760, perCellMax = 160;
  const total = Math.min(maxTotal, Math.max(N*80, N*perCellMax));
  const cellSize = Math.floor(total / N);

  const root = document.createElement('div'); root.style.position='relative'; root.style.width = total + 'px'; root.style.maxWidth='100%';
  const gridEl = document.createElement('div'); gridEl.className='grid';
  gridEl.style.gridTemplateColumns = `repeat(${N}, ${cellSize}px)`;
  gridEl.style.gridAutoRows = `${Math.floor(cellSize*0.85)}px`;
  gridEl.style.width = total + 'px';

  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      const cell = grid[r][c];
      const cellEl = document.createElement('div');
      cellEl.className = 'cell ' + (RARITIES[cell.rarityKey] ? RARITIES[cell.rarityKey].cls : RARITIES['common'].cls);
      cellEl.dataset.r = r; cellEl.dataset.c = c;

      const itemEl = document.createElement('div'); itemEl.className='item'; itemEl.textContent = cell.item;
      const rarityEl = document.createElement('div'); rarityEl.className='rarity'; rarityEl.textContent = (RARITIES[cell.rarityKey]||RARITIES['common']).key;
      const pointsEl = document.createElement('div'); pointsEl.className='points'; pointsEl.textContent = cell.basePts + ' pts';

      cellEl.appendChild(itemEl); cellEl.appendChild(rarityEl); cellEl.appendChild(pointsEl);
      const mark = document.createElement('div'); mark.className='overlayMark'; cellEl.appendChild(mark);

      cellEl.addEventListener('click', ()=>{ cycleMark(r,c); renderEverything(); });

      gridEl.appendChild(cellEl);
    }
  }

  const lineLayer = document.createElement('div'); lineLayer.className='line-layer';
  root.appendChild(gridEl); root.appendChild(lineLayer); container.appendChild(root);
}

function cycleMark(r,c){ const cur = grid[r][c].mark; grid[r][c].mark = cur===null ? 'X' : (cur==='X' ? 'O' : null); }

function getLinesForTeam(team){
  const res=[];
  for(let r=0;r<N;r++){ let ok=true; for(let c=0;c<N;c++){ if(grid[r][c].mark !== team){ ok=false; break; } } if(ok) res.push({type:'row',i:r}); }
  for(let c=0;c<N;c++){ let ok=true; for(let r=0;r<N;r++){ if(grid[r][c].mark !== team){ ok=false; break; } } if(ok) res.push({type:'col',i:c}); }
  let ok=true; for(let i=0;i<N;i++){ if(grid[i][i].mark !== team){ ok=false; break; } } if(ok) res.push({type:'diag',which:0});
  ok=true; for(let i=0;i<N;i++){ if(grid[i][N-1-i].mark !== team){ ok=false; break; } } if(ok) res.push({type:'diag',which:1});
  return res;
}

function renderEverything(){
  const container = document.getElementById('gridContainer'); const root = container.querySelector('div'); if(!root) return;
  const gridEl = root.querySelector('.grid'); if(!gridEl) return;

  const cells = gridEl.querySelectorAll('.cell');
  cells.forEach(cellEl=>{
    const r = parseInt(cellEl.dataset.r,10), c = parseInt(cellEl.dataset.c,10);
    const mEl = cellEl.querySelector('.overlayMark'); const mark = grid[r][c].mark;
    mEl.className = 'overlayMark';
    if(mark === 'X'){ mEl.classList.add('x'); mEl.textContent='X'; }
    else if(mark === 'O'){ mEl.classList.add('o'); mEl.textContent='O'; }
    else mEl.textContent='';
    cellEl.classList.remove('glow');
  });

  lines.X = getLinesForTeam('X'); lines.O = getLinesForTeam('O');

  const lineLayer = root.querySelector('.line-layer'); if(lineLayer) lineLayer.innerHTML='';

  const inLine = {}; for(let r=0;r<N;r++) for(let c=0;c<N;c++) inLine[`${r},${c}`] = {X:false,O:false};

  ['X','O'].forEach(team=>{
    (lines[team]||[]).forEach(ln=>{
      if(ln.type==='row'){ const r=ln.i; for(let c=0;c<N;c++) inLine[`${r},${c}`][team]=true; drawRowOverlay(r,team); }
      else if(ln.type==='col'){ const c=ln.i; for(let r=0;r<N;r++) inLine[`${r},${c}`][team]=true; drawColOverlay(c,team); }
      else if(ln.type==='diag'){ if(ln.which===0){ for(let i=0;i<N;i++) inLine[`${i},${i}`][team]=true; drawDiagOverlay(0,team);} else { for(let i=0;i<N;i++) inLine[`${i},${N-1-i}`][team]=true; drawDiagOverlay(1,team);} }
    });
  });

  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      const key = `${r},${c}`; const el = gridEl.children[r*N + c];
      if(!el) continue;
      if(grid[r][c].mark === 'X' && inLine[key].X) el.classList.add('glow');
      if(grid[r][c].mark === 'O' && inLine[key].O) el.classList.add('glow');
    }
  }

  let scoreX = 0, scoreO = 0;
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      const cell = grid[r][c]; const key = `${r},${c}`; const mark = cell.mark;
      if(mark === 'X'){ const multiplier = inLine[key].X ? 2 : 1; scoreX += cell.basePts * multiplier; }
      else if(mark === 'O'){ const multiplier = inLine[key].O ? 2 : 1; scoreO += cell.basePts * multiplier; }
      const idx = r*N + c; const cellEl = gridEl.children[idx]; const ptsEl = cellEl.querySelector('.points');
      let eff = cell.basePts;
      if(cell.mark === 'X' && inLine[key].X) eff = cell.basePts * 2;
      if(cell.mark === 'O' && inLine[key].O) eff = cell.basePts * 2;
      ptsEl.textContent = eff + ' pts';
    }
  }

  document.getElementById('scoreX').textContent = scoreX; document.getElementById('scoreO').textContent = scoreO;
  prevLines.X = JSON.parse(JSON.stringify(lines.X)); prevLines.O = JSON.parse(JSON.stringify(lines.O));
}

// overlays
function drawRowOverlay(rowIndex, team){
  const container = document.getElementById('gridContainer'); const root = container.querySelector('div'); if(!root) return;
  const gridEl = root.querySelector('.grid'); const lineLayer = root.querySelector('.line-layer'); if(!gridEl || !lineLayer) return;
  const cells = gridEl.querySelectorAll('.cell');
  const first = cells[rowIndex*N + 0].getBoundingClientRect();
  const last  = cells[rowIndex*N + (N-1)].getBoundingClientRect();
  const gridRect = gridEl.getBoundingClientRect();
  const left = first.left - gridRect.left; const top = first.top - gridRect.top;
  const width = last.right - first.left; const height = first.height;
  const div = document.createElement('div'); div.className='lineOverlay';
  div.style.position='absolute'; div.style.left = left + 'px'; div.style.top = top + 'px';
  div.style.width = width + 'px'; div.style.height = height + 'px';
  div.style.background = team==='X' ? 'rgba(221,68,68,0.28)' : 'rgba(42,142,42,0.28)';
  div.style.borderRadius='6px'; lineLayer.appendChild(div);
}
function drawColOverlay(colIndex, team){
  const container = document.getElementById('gridContainer'); const root = container.querySelector('div'); if(!root) return;
  const gridEl = root.querySelector('.grid'); const lineLayer = root.querySelector('.line-layer'); if(!gridEl || !lineLayer) return;
  const cells = gridEl.querySelectorAll('.cell');
  const first = cells[0*N + colIndex].getBoundingClientRect();
  const last  = cells[(N-1)*N + colIndex].getBoundingClientRect();
  const gridRect = gridEl.getBoundingClientRect();
  const left = first.left - gridRect.left; const top = first.top - gridRect.top;
  const width = first.width; const height = (last.bottom - first.top);
  const div = document.createElement('div'); div.className='lineOverlay';
  div.style.position='absolute'; div.style.left = left + 'px'; div.style.top = top + 'px';
  div.style.width = width + 'px'; div.style.height = height + 'px';
  div.style.background = team==='X' ? 'rgba(221,68,68,0.28)' : 'rgba(42,142,42,0.28)';
  div.style.borderRadius='6px'; lineLayer.appendChild(div);
}
function drawDiagOverlay(which, team){
  const container = document.getElementById('gridContainer'); const root = container.querySelector('div'); if(!root) return;
  const gridEl = root.querySelector('.grid'); const lineLayer = root.querySelector('.line-layer'); if(!gridEl || !lineLayer) return;
  const gridRect = gridEl.getBoundingClientRect(); const cells = gridEl.querySelectorAll('.cell');
  const a = which===0 ? cells[0].getBoundingClientRect() : cells[N-1].getBoundingClientRect();
  const b = which===0 ? cells[(N-1)*N + (N-1)].getBoundingClientRect() : cells[(N-1)*N + 0].getBoundingClientRect();
  const ax = (a.left - gridRect.left) + a.width/2; const ay = (a.top - gridRect.top) + a.height/2;
  const bx = (b.left - gridRect.left) + b.width/2; const by = (b.top - gridRect.top) + b.height/2;
  const svgNS = "http://www.w3.org/2000/svg"; const svg = document.createElementNS(svgNS,'svg');
  svg.setAttribute('width', gridRect.width); svg.setAttribute('height', gridRect.height);
  svg.style.position='absolute'; svg.style.left='0'; svg.style.top='0';
  const line = document.createElementNS(svgNS,'line');
  line.setAttribute('x1', ax); line.setAttribute('y1', ay); line.setAttribute('x2', bx); line.setAttribute('y2', by);
  line.setAttribute('stroke', team==='X' ? 'rgba(221,68,68,0.35)' : 'rgba(42,142,42,0.35)');
  line.setAttribute('stroke-width', Math.max(10, Math.min(36, Math.min(a.width,a.height)*0.6)));
  line.setAttribute('stroke-linecap','round'); svg.appendChild(line); svg.classList.add('lineOverlay'); lineLayer.appendChild(svg);
}

// UI wiring
document.getElementById('toStep2').addEventListener('click', ()=>{ document.getElementById('step1').style.display='none'; document.getElementById('step2').style.display='block'; });

document.getElementById('parseBtn').addEventListener('click', ()=>{
  const teamX = document.getElementById('teamXName').value || 'Team X';
  const teamO = document.getElementById('teamOName').value || 'Team O';
  document.getElementById('teamXDisplay').textContent = teamX;
  document.getElementById('teamODisplay').textContent = teamO;
  const text = document.getElementById('cardInput').value;
  if(!text || !text.trim()){ alert('Please paste card text.'); return; }
  const parsed = parseCardText(text);
  const pairs = parsed.map(p => ({ item: p.item, rarityRaw: p.rarityRaw || '', rarity: p.rarity || null }));
  const built = buildGridFromPairs(pairs);
  if(!built){ alert('Could not parse a square card from the text. Make sure there are between 1 and 100 cells and the total is a perfect square (1x1 .. 10x10).'); return; }
  document.getElementById('cardSize').textContent = N + ' x ' + N;
  // legend
  const legend = document.getElementById('legend'); legend.innerHTML='';
  ['very common','common','uncommon','rare','super rare'].forEach(k=>{
    const d = document.createElement('div'); d.className='key '+RARITIES[k].cls; d.style.padding='8px';
    d.textContent = RARITIES[k].key + ' — ' + RARITIES[k].pts + ' pts'; legend.appendChild(d);
  });
  document.getElementById('step2').style.display='none';
  document.getElementById('viewer').style.display='block';
  renderGrid();
  requestAnimationFrame(()=>{ renderEverything(); });
});

document.getElementById('resetMarks').addEventListener('click', ()=>{ for(let r=0;r<N;r++) for(let c=0;c<N;c++) grid[r][c].mark = null; renderEverything(); });
document.getElementById('exportBtn').addEventListener('click', ()=>{
  const flat = [];
  for(let r=0;r<N;r++) for(let c=0;c<N;c++){ const cell = grid[r][c]; flat.push((cell.item||'') + '\n' + ((RARITIES[cell.rarityKey]||RARITIES['common']).key)); }
  prompt('Copy the card text below (paste back into the importer to recreate the card):', flat.join('\n'));
});
</script>
</body>
</html>
