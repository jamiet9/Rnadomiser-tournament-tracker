<!doctype html>
const res=[];
for(let r=0;r<N;r++){ let ok=true; for(let c=0;c<N;c++){ if(grid[r][c].mark !== team){ ok=false; break;} } if(ok) res.push({type:'row',i:r}); }
for(let c=0;c<N;c++){ let ok=true; for(let r=0;r<N;r++){ if(grid[r][c].mark !== team){ ok=false; break;} } if(ok) res.push({type:'col',i:c}); }
let ok=true; for(let i=0;i<N;i++){ if(grid[i][i].mark !== team){ ok=false; break;} } if(ok) res.push({type:'diag',which:0});
ok=true; for(let i=0;i<N;i++){ if(grid[i][N-1-i].mark !== team){ ok=false; break;} } if(ok) res.push({type:'diag',which:1});
return res;
}


function arraysEqual(a,b){ if(a.length!==b.length) return false; const sa = JSON.stringify(a); const sb = JSON.stringify(b); return sa===sb; }


function renderEverything(){
const gridRoot = document.querySelector('#gridContainer .grid-root'); if(!gridRoot) return; const gridEl = gridRoot.querySelector('.grid'); const lineLayer = gridRoot.querySelector('.line-layer');
const cells = gridEl.querySelectorAll('.cell');
cells.forEach(cellEl=>{ const r=parseInt(cellEl.dataset.r), c=parseInt(cellEl.dataset.c); const mEl=cellEl.querySelector('.overlayMark'); const mark=grid[r][c].mark; mEl.className='overlayMark'; if(mark==='X'){ mEl.classList.add('x'); mEl.textContent='X'; } else if(mark==='O'){ mEl.classList.add('o'); mEl.textContent='O'; } else { mEl.textContent=''; } cellEl.classList.remove('glow'); });


// compute completed lines
lines.X = getLinesForTeam('X'); lines.O = getLinesForTeam('O');


// detect newly completed lines to play sound once
const newX = !arraysEqual(lines.X, prevLines.X);
const newO = !arraysEqual(lines.O, prevLines.O);


// clear overlays
lineLayer.innerHTML = '';


// map whether cell is in any completed line for a team (non-stacking)
const inLine = {};
for(let r=0;r<N;r++) for(let c=0;c<N;c++) inLine[`${r},${c}`] = {X:false,O:false};


['X','O'].forEach(team=>{ (lines[team]||[]).forEach(ln=>{
if(ln.type==='row'){ const r=ln.i; for(let c=0;c<N;c++) inLine[`${r},${c}`][team]=true; drawRowOverlay(r,team); }
else if(ln.type==='col'){ const c=ln.i; for(let r=0;r<N;r++) inLine[`${r},${c}`][team]=true; drawColOverlay(c,team); }
else if(ln.type==='diag'){ if(ln.which===0){ for(let i=0;i<N;i++) inLine[`${i},${i}`][team]=true; drawDiagOverlay(0,team);} else { for(let i=0;i<N;i++) inLine[`${i},${N-1-i}`][team]=true; drawDiagOverlay(1,team);} }
}); });


// apply glow to any marked cell that is doubled
for(let r=0;r<N;r++){
for(let c=0;c<N;c++){
const key = `${r},${c}`; const el = gridEl.children[r*N + c]; if(!el) continue;
if(grid[r][c].mark === 'X' && inLine[key].X) el.classList.add('glow');
if(grid[r][c].mark === 'O' && inLine[key].O) el.classList.add('glow');
}
}


// compute scores (doubling at most once)
let scoreX = 0, scoreO = 0;
for(let r=0;r<N;r++){
for(let c=0;c<N;c++){
const cell = grid[r][c]; const key=`${r},${c}`; const mark = cell.mark;
if(mark === 'X'){ const multiplier = inLine[key].X ? 2 : 1; scoreX += cell.basePts * multiplier; }
else if(mark === 'O'){ const multiplier = inLine[key].O ? 2 : 1; scoreO += cell.basePts * multiplier; }
const ptsEl = gridEl.children[r*N+c].querySelector('.points'); let eff = cell.basePts; if(mark==='X' && inLine[key].X) eff = cell.basePts*2; if(mark==='O' && inLine[key].O) eff = cell.basePts*2; ptsEl.textContent = eff + ' pts';
}
}


document.getElementById('scoreX').textContent = scoreX; document.getElementById('scoreO').textContent = scoreO;


// play line sound if new lines detected
if((newX || newO) && (lines.X.length + lines.O.length) > 0){ playLineAudio(); }


// store current as prev for next render
prevLines.X = JSON.parse(JSON.stringify(lines.X)); prevLines.O = JSON.parse(JSON.stringify(lines.O));
}


// overlay drawing helpers — precise bounding boxes
function drawRowOverlay(r,team){ const root = document.querySelector('#gridContainer .grid-root'); const gridEl = root.querySelector('.grid'); const lineLayer = root.querySelector('.line-layer'); const first = gridEl.children[r*N + 0].getBoundingClientRect(); const last = gridEl.children[r*N + (N-1)].getBoundingClientRect(); const gridRect = gridEl.getBoundingClientRect(); const left = first.left - gridRect.left; const top = first.top - gridRect.top; const width = last.right - first.left; const height = first.height; const div = document.createElement('div'); div.className='lineOverlay'; div.style.left = left + 'px'; div.style.top = top + 'px'; div.style.width = width + 'px'; div.style.height = height + 'px'; div.style.background = team==='X' ? 'rgba(221,68,68,0.28)' : 'rgba(42,142,42,0.28)'; lineLayer.appendChild(div); }
function drawColOverlay(c,team){ const root = document.querySelector('#gridContainer .grid-root'); const gridEl = root.querySelector('.grid'); const lineLayer = root.querySelector('.line-layer'); const first = gridEl.children[0*N + c].getBoundingClientRect(); const last = gridEl.children[(N-1)*N + c].getBoundingClientRect(); const gridRect = gridEl.getBoundingClientRect(); const left = first.left - gridRect.left; const top = first.top - gridRect.top; const width = first.width; const height = (last.bottom - first.top); const div = document.createElement('div'); div.className='lineOverlay'; div.style.left = left + 'px'; div.style.top = top + 'px'; div.style.width = width + 'px'; div.style.height = height + 'px'; div.style.background = team==='X' ? 'rgba(221,68,68,0.28)' : 'rgba(42,142,42,0.28)'; lineLayer.appendChild(div); }
function drawDiagOverlay(which,team){ const root = document.querySelector('#gridContainer .grid-root'); const gridEl = root.querySelector('.grid'); const lineLayer = root.querySelector('.line-layer'); const gridRect = gridEl.getBoundingClientRect(); const a = which===0 ? gridEl.children[0].getBoundingClientRect() : gridEl.children[N-1].getBoundingClientRect(); const b = which===0 ? gridEl.children[(N-1)*N + (N-1)].getBoundingClientRect() : gridEl.children[(N-1)*N + 0].getBoundingClientRect(); const svgNS='http://www.w3.org/2000/svg'; const svg = document.createElementNS(svgNS,'svg'); svg.setAttribute('width', gridRect.width); svg.setAttribute('height', gridRect.height); svg.style.position='absolute'; svg.style.left='0'; svg.style.top='0'; const line = document.createElementNS(svgNS,'line'); const ax = (a.left - gridRect.left) + a.width/2; const ay = (a.top - gridRect.top) + a.height/2; const bx = (b.left - gridRect.left) + b.width/2; const by = (b.top - gridRect.top) + b.height/2; line.setAttribute('x1',ax); line.setAttribute('y1',ay); line.setAttribute('x2',bx); line.setAttribute('y2',by); line.setAttribute('stroke', team==='X' ? 'rgba(221,68,68,0.35)' : 'rgba(42,142,42,0.35)'); line.setAttribute('stroke-width', Math.max(10, Math.min(36, Math.min(a.width,a.height)*0.6))); line.setAttribute('stroke-linecap','round'); svg.appendChild(line); svg.classList.add('lineOverlay'); lineLayer.appendChild(svg); }


// UI wiring
document.getElementById('toStep2').addEventListener('click', ()=>{ document.getElementById('step1').style.display='none'; document.getElementById('step2').style.display='block'; });


// parse and render
document.getElementById('parseBtn').addEventListener('click', ()=>{
// load sounds from inputs
const sx = document.getElementById('soundXUrl').value.trim(); const so = document.getElementById('soundOUrl').value.trim(); const sl = document.getElementById('soundLineUrl').value.trim(); audioX = sx ? new Audio(sx) : null; audioO = so ? new Audio(so) : null; audioLine = sl ? new Audio(sl) : null;


const teamX = document.getElementById('teamXName').value || 'Team X'; const teamO = document.getElementById('teamOName').value || 'Team O'; document.getElementById('teamXDisplay').textContent = teamX; document.getElementById('teamODisplay').textContent = teamO;
const text = document.getElementById('cardInput').value.trim(); if(!text){ alert('Please paste card text.'); return; }
const pairs = parseCardText(text);
const built = buildGridFromPairs(pairs);
if(!built){ alert('Could not parse a square card from the text. Make sure the total number of cells is a perfect square (1x1 .. 10x10).'); return; }
document.getElementById('cardSize').textContent = N + ' x ' + N;


// legend
const legend = document.getElementById('legend'); legend.innerHTML='';
for(const key of ['very common','common','uncommon','rare','super rare']){ const d=document.createElement('div'); d.className='key '+RARITIES[key].cls; d.style.padding='8px'; d.textContent = RARITIES[key].key + ' — ' + RARITIES[key].pts + ' pts'; legend.appendChild(d); }


document.getElementById('step2').style.display='none'; document.getElementById('viewer').style.display='block';
renderGrid(); requestAnimationFrame(()=>{ renderEverything(); });
});


// reset marks
document.getElementById('resetMarks').addEventListener('click', ()=>{ for(let r=0;r<N;r++) for(let c=0;c<N;c++) grid[r][c].mark = null; renderEverything(); });


// export
document.getElementById('exportBtn').addEventListener('click', ()=>{
const flat = [];
for(let r=0;r<N;r++) for(let c=0;c<N;c++){ const cell = grid[r][c]; flat.push((cell.item||'') + '\n' + RARITIES[cell.rarityKey].key); }
prompt('Copy the card text below (paste back into the importer to recreate the card):', flat.join('\n'));
});
</script>
</body>
</html>
